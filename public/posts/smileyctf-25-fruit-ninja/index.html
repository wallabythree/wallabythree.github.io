<!doctype html><html lang=en-gb dir=ltr><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><title>smileyCTF 2025: Fruit Ninja</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.classless.min.css></head><body><header><h1><a href=/>wallaby</a></h1><nav></nav></header><main><article><h1>smileyCTF 2025: Fruit Ninja</h1><i><time>2025-06-19</time></i><blockquote><p>my friend made a custom cpu, so of course i had to make a game for it. can you win? @unvariant REMEMBER TO GIVE THEM CPU</p><p><code>rev</code>, 8 solves, created by flocto</p></blockquote><p><em>Fruit Ninja</em> was a fun challenge from last week&rsquo;s smileyCTF. It involved reverse engineering code written for a custom RISC-V 32 processor with a Harvard architecture, which could be relinked using a custom linker script to allow for easy static analysis. This revealed a straightforward flag checking scheme that could trivially be brute forced.</p><h2 id=1-first-steps>1. First steps</h2><p>The challenge gives us the following files:</p><ul><li><code>fruitninja/ram_file.mem</code></li><li><code>fruitninja/rom_file.mem</code></li><li><code>fruitninja/vcpu*</code>: a simulator for the custom CPU</li><li><code>fruitninja/src</code>: a directory containing files like <code>CPU.sv</code> and <code>RAM.sv</code></li></ul><p>A quick Google search reveals that <code>sv</code> stands for <a href>SystemVerilog</a>, a hardware description language useful for describing CPUs. So <code>src</code> contains the custom CPU&rsquo;s &ldquo;source code&rdquo;.</p><p>We&rsquo;ll probably need to reverse the ROM to solve this challenge, so let&rsquo;s take a look inside <code>rom_file.mem</code> and <code>ram_file.mem</code>:</p><p><strong>rom_file.mem</strong></p><pre tabindex=0><code>@00000000
00020137 00000097 254080e7 ff010113 00112623 00812423 [...]
</code></pre><p><strong>ram_file.mem</strong></p><pre tabindex=0><code>@00000000
4e26d7c6 2f676fc6 3bec4bac 7806aa71 710fa7cf 655a0ef2 [...]
</code></pre><p>Clearly, these look like memory dumps with an address at the top and the actual data on the next line. However, we don&rsquo;t know how to decode this data until we know the CPU&rsquo;s instruction set.</p><h2 id=2-discovering-the-instruction-set>2. Discovering the instruction set</h2><p>Every CPU has an decoder that breaks down the zeroes and ones of a program into instructions it understands. If we can find the logic for the decoder, we know what operations our processor supports and how they are encoded.</p><p>Exploring <code>src/</code>, we find this intriguing enum in <code>CPU.h.sv</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SystemVerilog data-lang=SystemVerilog><span style=display:flex><span><span style=color:#f92672>package</span> Opcode;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> <span style=color:#66d9ef>logic</span> [<span style=color:#ae81ff>6</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] {
</span></span><span style=display:flex><span>        RegImm <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span><span style=color:#ae81ff>&#39;b00</span>_100_11,
</span></span><span style=display:flex><span>        RegReg <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span><span style=color:#ae81ff>&#39;b01</span>_100_11,
</span></span><span style=display:flex><span>        Load   <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span><span style=color:#ae81ff>&#39;b00</span>_000_11,
</span></span><span style=display:flex><span>        Store  <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span><span style=color:#ae81ff>&#39;b01</span>_000_11,
</span></span><span style=display:flex><span>        Branch <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span><span style=color:#ae81ff>&#39;b11</span>_000_11,
</span></span><span style=display:flex><span>        Jal    <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span><span style=color:#ae81ff>&#39;b11</span>_011_11,
</span></span><span style=display:flex><span>        Jalr   <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span><span style=color:#ae81ff>&#39;b11</span>_001_11,
</span></span><span style=display:flex><span>        Lui    <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span><span style=color:#ae81ff>&#39;b01</span>_101_11,
</span></span><span style=display:flex><span>        Auipc  <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span><span style=color:#ae81ff>&#39;b00</span>_101_11
</span></span><span style=display:flex><span>    } Opcode;
</span></span><span style=display:flex><span><span style=color:#66d9ef>endpackage</span>
</span></span></code></pre></div><p>If you know RISC-V, these opcodes will look familiar: they are identical to those used to encode RISC-V instructions. Also, in <code>Register.sv</code> we find the line <code>logic [31:0] registers[31:0]</code>, so it seems we are dealing with a RISC-V 32 processor.</p><p>Now that we know the instruction set, we should be able to disassemble the ROM. We can do this with <code>capstone</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> capstone <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>disasm</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;rom_file.mem&#34;</span>, <span style=color:#e6db74>&#34;r&#34;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>        words <span style=color:#f92672>=</span> f<span style=color:#f92672>.</span>read()[<span style=color:#ae81ff>1</span>:]<span style=color:#f92672>.</span>split()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	addr <span style=color:#f92672>=</span> int(words[<span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>16</span>)
</span></span><span style=display:flex><span>	instructions <span style=color:#f92672>=</span> [bytes<span style=color:#f92672>.</span>fromhex(instr) <span style=color:#66d9ef>for</span> instr <span style=color:#f92672>in</span> words[<span style=color:#ae81ff>1</span>:]]
</span></span><span style=display:flex><span>	rom <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>.</span>join(instructions)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    md <span style=color:#f92672>=</span> Cs(CS_ARCH_RISCV, CS_MODE_32)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> md<span style=color:#f92672>.</span>disasm(rom, addr):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>i<span style=color:#f92672>.</span>mnemonic<span style=color:#e6db74>}</span><span style=color:#e6db74> </span><span style=color:#e6db74>{</span>i<span style=color:#f92672>.</span>op_str<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><p>Yet, the initial disassembly seems to be nonsensical:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>c.addi4spn</span> <span style=color:#66d9ef>s0</span>, <span style=color:#66d9ef>sp</span>, <span style=color:#ae81ff>0x100</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>c.jal</span> -<span style=color:#ae81ff>0x100</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>c.unimp</span>
</span></span></code></pre></div><p>What if the memory dump is big-endian? Let&rsquo;s try reversing the byte order for each word:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># convert instructions to little-endian by reversing the bytes in each word</span>
</span></span><span style=display:flex><span>instructions <span style=color:#f92672>=</span> [bytes<span style=color:#f92672>.</span>fromhex(instr)[::<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#66d9ef>for</span> instr <span style=color:#f92672>in</span> words[<span style=color:#ae81ff>1</span>:]]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>lui</span> <span style=color:#66d9ef>sp</span>, <span style=color:#ae81ff>0x20</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>auipc</span> <span style=color:#66d9ef>ra</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>jalr</span> <span style=color:#66d9ef>ra</span>, <span style=color:#66d9ef>ra</span>, <span style=color:#ae81ff>0x254</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>sp</span>, <span style=color:#66d9ef>sp</span>, -<span style=color:#ae81ff>0x10</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sw</span> <span style=color:#66d9ef>ra</span>, <span style=color:#ae81ff>0xc</span>(<span style=color:#66d9ef>sp</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>sw</span> <span style=color:#66d9ef>s0</span>, <span style=color:#ae81ff>8</span>(<span style=color:#66d9ef>sp</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>sw</span> <span style=color:#66d9ef>s1</span>, <span style=color:#ae81ff>4</span>(<span style=color:#66d9ef>sp</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>sw</span> <span style=color:#66d9ef>s2</span>, <span style=color:#ae81ff>0</span>(<span style=color:#66d9ef>sp</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>mv</span> <span style=color:#66d9ef>s0</span>, <span style=color:#66d9ef>a0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mv</span> <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>zero</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>beqz</span> <span style=color:#66d9ef>a1</span>, <span style=color:#ae81ff>0x1a4</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>beqz</span> <span style=color:#66d9ef>s0</span>, <span style=color:#ae81ff>0x1a0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>s1</span>, <span style=color:#66d9ef>zero</span>, <span style=color:#ae81ff>0x20</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>s2</span>, <span style=color:#66d9ef>zero</span>, <span style=color:#ae81ff>0x20</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>beqz</span> <span style=color:#66d9ef>a1</span>, <span style=color:#ae81ff>0x90</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>srli</span> <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a1</span>, <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#75715e># [...]
</span></span></span></code></pre></div><p>Success! So, we&rsquo;re dealing with a RISC-V 32 CPU. Whew, that simplifies things: we can use standard RISC-V tools to analyse the ROM. Let&rsquo;s save the disassembly in <code>rom.S</code> and the RAM as raw little-endian bytes in <code>ram.bin</code>.</p><h2 id=3-discovering-the-memory-architecture>3. Discovering the memory architecture</h2><p>There is something odd about <code>ram_file.mem</code> and <code>rom_file.mem</code>. They both start with <code>@00000000</code>, telling the CPU to load both RAM and ROM at the same address.</p><p><img src=https://upload.wikimedia.org/wikipedia/commons/3/3f/Harvard_architecture.svg alt="Harvard architecture"></p><p>On a Von Neumann architecture (which most personal computers use), loading both the RAM and ROM to address <code>00000000</code> would cause them to overwrite each other. But on a Harvard architecture, the ROM will end up in instruction memory and the RAM in data memory, so both can be stored at <code>00000000</code>. This program seems like it was developed for a Harvard machine. Binary Ninja, our decompiler, expects a Von Neumann architecture, so we&rsquo;ll have to fix this.</p><p>Fortunately, we can use a custom linker script to decide where things get loaded. The assembly in our ROM contains only relative jumps, so it&rsquo;s position-independent and can theoretically be loaded anywhere. We just need to make sure the RAM is at address <code>000000</code>, because that&rsquo;s where our assembly expects it to be.</p><pre tabindex=0><code class=language-ld data-lang=ld>OUTPUT_FORMAT(&#34;elf32-littleriscv&#34;)
ENTRY(_start)

MEMORY
{
  RAM (rw) : ORIGIN = 0x00000000, LENGTH = 128K
  ROM (rx)  : ORIGIN = 0x00080000, LENGTH = 128K
}

SECTIONS
{
  .data : {
    *(.data)
  } &gt; RAM

  .text : {
    *(.text)
  } &gt; ROM
}
</code></pre><p>With this linker script, we can assemble and relink the ROM and RAM into a single ELF file. (I like to use <code>clang</code> as it produces a closer mapping to the original assembly.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>clang --target<span style=color:#f92672>=</span>riscv32 -march<span style=color:#f92672>=</span>rv32i rom.S -c -o rom.o <span style=color:#f92672>&amp;&amp;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>riscv64-unknown-elf-objcopy -I binary -O elf32-littleriscv -B riscv ram.bin ram.o <span style=color:#f92672>&amp;&amp;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>riscv64-unknown-elf-ld rom.o ram.o -T linker.ld -o fruit.elf
</span></span></code></pre></div><h2 id=4-analysing-the-rom>4. Analysing the ROM</h2><p>With a functional ELF file, we can load it up in Binary Ninja and analyse the pseudocode. Inside, we find several helper functions (including a manual <code>modulo(uint32_t dividend, uint32_t divisor)</code> implementation) and a function that looks like <code>main()</code>.</p><p>By looking at strings being loaded by the disassembly, we can infer what the <code>write(char*)</code> and <code>read(char*)</code> functions are.</p><p><img src=main.png alt="main() disassembly"></p><p>This gives us the following pseudocode for <code>main()</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int32_t</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>write</span>(<span style=color:#e6db74>&#34;cut my fruit in half: &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>0x25</span>];
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>read</span>(<span style=color:#f92672>&amp;</span>buffer) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x25</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int32_t</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint32_t</span> tmp <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int32_t</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> var_25_1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int32_t</span> encoded[<span style=color:#ae81ff>0x32</span>];
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>uint32_t</span> c <span style=color:#f92672>=</span> ((<span style=color:#66d9ef>uint32_t</span>)buffer[i]);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int32_t</span> i_mod_3 <span style=color:#f92672>=</span> <span style=color:#a6e22e>modulo</span>((i <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xff</span>), <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int32_t</span> shift <span style=color:#f92672>=</span> (i_mod_3 <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int32_t</span> j_1 <span style=color:#f92672>=</span> (j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            encoded[j] <span style=color:#f92672>=</span> (((c <span style=color:#f92672>&lt;&lt;</span> shift) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x3f</span>) <span style=color:#f92672>|</span> tmp);
</span></span><span style=display:flex><span>            tmp <span style=color:#f92672>=</span> (c <span style=color:#f92672>&gt;&gt;</span> (shift <span style=color:#f92672>^</span> <span style=color:#ae81ff>6</span>));
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i_mod_3 <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                encoded[j_1] <span style=color:#f92672>=</span> tmp;
</span></span><span style=display:flex><span>                j_1 <span style=color:#f92672>=</span> (j <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>                tmp <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            j <span style=color:#f92672>=</span> j_1;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0x26</span>);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int32_t</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int32_t</span><span style=color:#f92672>*</span> array_1 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>ARRAY;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int32_t</span> valid <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x32</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int32_t</span> l <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int32_t</span> acc <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int32_t</span><span style=color:#f92672>*</span> array_2 <span style=color:#f92672>=</span> array_1;
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int32_t</span> val <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(<span style=color:#66d9ef>uint32_t</span><span style=color:#f92672>*</span>)array_2;
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (l <span style=color:#f92672>&gt;=</span> encoded[k])
</span></span><span style=display:flex><span>                    val <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span> <span style=color:#f92672>-</span> val);
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                acc <span style=color:#f92672>+=</span> val;
</span></span><span style=display:flex><span>                l <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                array_2 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>array_2[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>while</span> (l <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0x40</span>);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            valid <span style=color:#f92672>-=</span> ((acc <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>?</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>            k <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            array_1 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>array_1[<span style=color:#ae81ff>0x40</span>];
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>while</span> (k <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0x32</span>);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (valid <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>write</span>(<span style=color:#e6db74>&#34;yes</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>write</span>(<span style=color:#e6db74>&#34;no</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The first part looks like it reads 37 input bytes and encodes them into 50 6-bit values using some kind of custom Base64 variant. The second part checks each of the 50 values against a separate array of 64 integers that are summed together. Only if the sum of these values is zero will the 6-bit value be seen as valid. The 6-bit value determines at what point all following array values will be treated as negative numbers, changing the final sum. Essentially, this is a simplified version of the <a href=https://en.wikipedia.org/wiki/Partition_problem>partition problem</a>.</p><p>Because each 6-bit value has only 64 possible values, and the correctness of one 6-bit value can be independently verified from the others, we can easily brute force the encoded flag.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>retrieve_arr</span>():
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;&#34;&#34;Retrieve the int32_t ARRAY[50][64] from `ram_file.mem`&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;ram_file.mem&#34;</span>, <span style=color:#e6db74>&#34;r&#34;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>        _, raw_mem <span style=color:#f92672>=</span> f<span style=color:#f92672>.</span>readlines()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># read values into flat array</span>
</span></span><span style=display:flex><span>    vals <span style=color:#f92672>=</span> [int(word, <span style=color:#ae81ff>16</span>) <span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> raw_mem<span style=color:#f92672>.</span>strip()<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39; &#39;</span>)][:<span style=color:#ae81ff>0x32</span><span style=color:#f92672>*</span><span style=color:#ae81ff>0x40</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># divide flat array into subarrays of 64 values each</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [vals[i:i<span style=color:#f92672>+</span><span style=color:#ae81ff>0x40</span>] <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, len(vals), <span style=color:#ae81ff>0x40</span>)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>guess</span>(a: list[int], n: int) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>    acc <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># sum all values in the array</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, val <span style=color:#f92672>in</span> enumerate(a):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e># once i exceeds our guess, treat subsequent values as negative</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&gt;=</span> n:
</span></span><span style=display:flex><span>            val <span style=color:#f92672>*=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        acc <span style=color:#f92672>+=</span> val
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> acc <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xffffffff</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>brute</span>() <span style=color:#f92672>-&gt;</span> bytes:
</span></span><span style=display:flex><span>    A <span style=color:#f92672>=</span> retrieve_arr()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    flag64 <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> a <span style=color:#f92672>in</span> A:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> n <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>2</span><span style=color:#f92672>**</span><span style=color:#ae81ff>6</span>):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> guess(a, n):
</span></span><span style=display:flex><span>                flag64<span style=color:#f92672>.</span>append(n)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> flag64
</span></span></code></pre></div><p>Then, the flag can be decoded by inverting the original encoding:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>decode</span>(encoded_data: list[int]) <span style=color:#f92672>-&gt;</span> bytes:
</span></span><span style=display:flex><span>    decoded_bytes <span style=color:#f92672>=</span> bytearray()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> i <span style=color:#f92672>&lt;</span> len(encoded_data):
</span></span><span style=display:flex><span>        chunk <span style=color:#f92672>=</span> encoded_data[i:i<span style=color:#f92672>+</span><span style=color:#ae81ff>4</span>]
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        e0 <span style=color:#f92672>=</span> chunk[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> len(chunk) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>            e1 <span style=color:#f92672>=</span> chunk[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            c0 <span style=color:#f92672>=</span> ((e1 <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x03</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>6</span>) <span style=color:#f92672>|</span> e0
</span></span><span style=display:flex><span>            decoded_bytes<span style=color:#f92672>.</span>append(c0)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> len(chunk) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>            e2 <span style=color:#f92672>=</span> chunk[<span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>            c1 <span style=color:#f92672>=</span> ((e2 <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x0f</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>4</span>) <span style=color:#f92672>|</span> (e1 <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>            decoded_bytes<span style=color:#f92672>.</span>append(c1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> len(chunk) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>3</span>:
</span></span><span style=display:flex><span>            e3 <span style=color:#f92672>=</span> chunk[<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>            c2 <span style=color:#f92672>=</span> ((e3 <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x3f</span>) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>|</span> (e2 <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>            decoded_bytes<span style=color:#f92672>.</span>append(c2)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> bytes(decoded_bytes)
</span></span></code></pre></div><p>This quickly yields our flag:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> flag64 <span style=color:#f92672>=</span> brute()
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> decode(flag64)
</span></span><span style=display:flex><span><span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;.;,;.</span><span style=color:#e6db74>{PPPerfect_pr3c15e_p4rT1Ti0ning}</span><span style=color:#e6db74>&#39;</span>
</span></span></code></pre></div><h2 id=epilogue>Epilogue</h2><p>The difficulty in most custom CPU challenges (including VM challenges) lies in understanding the instruction set. Once the instruction set is known, implementation details like endianness and memory architecture are easy to overcome. Luckily, RISC-V is supported by many compilers and static analysis tools, so it was easy to compile this into a working binary and obtain the pseudocode. If a truly custom instruction set had been used, we would have had to manually analyse the assembly, which would have taken significantly more effort.</p></article></main><footer><p>CC-BY 4.0</p></footer></body></html>